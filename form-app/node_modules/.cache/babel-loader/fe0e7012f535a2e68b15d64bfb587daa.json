{"ast":null,"code":"import { a as _createClass, b as _classCallCheck, c as _objectWithoutProperties } from '../../_rollupPluginBabelHelpers-3c58f0e3.js';\nimport { isString } from '../../core/utils.js';\nimport ChangeDetails from '../../core/change-details.js';\nimport ContinuousTailDetails from '../../core/continuous-tail-details.js';\nimport IMask from '../../core/holder.js';\n\nvar ChunksTailDetails = /*#__PURE__*/function () {\n  /** */\n  function ChunksTailDetails() {\n    var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, ChunksTailDetails);\n\n    this.chunks = chunks;\n    this.from = from;\n  }\n\n  _createClass(ChunksTailDetails, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.chunks.map(String).join('');\n    } // $FlowFixMe no ideas\n\n  }, {\n    key: \"extend\",\n    value: function extend(tailChunk) {\n      if (!String(tailChunk)) return;\n      if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));\n      var lastChunk = this.chunks[this.chunks.length - 1];\n      var extendLast = lastChunk && ( // if stops are same or tail has no stop\n      lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && // if tail chunk goes just after last chunk\n      tailChunk.from === lastChunk.from + lastChunk.toString().length;\n\n      if (tailChunk instanceof ContinuousTailDetails) {\n        // check the ability to extend previous chunk\n        if (extendLast) {\n          // extend previous chunk\n          lastChunk.extend(tailChunk.toString());\n        } else {\n          // append new chunk\n          this.chunks.push(tailChunk);\n        }\n      } else if (tailChunk instanceof ChunksTailDetails) {\n        if (tailChunk.stop == null) {\n          // unwrap floating chunks to parent, keeping `from` pos\n          var firstTailChunk;\n\n          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n            firstTailChunk = tailChunk.chunks.shift();\n            firstTailChunk.from += tailChunk.from;\n            this.extend(firstTailChunk);\n          }\n        } // if tail chunk still has value\n\n\n        if (tailChunk.toString()) {\n          // if chunks contains stops, then popup stop to container\n          tailChunk.stop = tailChunk.blockIndex;\n          this.chunks.push(tailChunk);\n        }\n      }\n    }\n  }, {\n    key: \"appendTo\",\n    value: function appendTo(masked) {\n      // $FlowFixMe\n      if (!(masked instanceof IMask.MaskedPattern)) {\n        var tail = new ContinuousTailDetails(this.toString());\n        return tail.appendTo(masked);\n      }\n\n      var details = new ChangeDetails();\n\n      for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n        var chunk = this.chunks[ci];\n\n        var lastBlockIter = masked._mapPosToBlock(masked.value.length);\n\n        var stop = chunk.stop;\n        var chunkBlock = void 0;\n\n        if (stop && ( // if block not found or stop is behind lastBlock\n        !lastBlockIter || lastBlockIter.index <= stop)) {\n          if (chunk instanceof ChunksTailDetails || // for continuous block also check if stop is exist\n          masked._stops.indexOf(stop) >= 0) {\n            details.aggregate(masked._appendPlaceholder(stop));\n          }\n\n          chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n        }\n\n        if (chunkBlock) {\n          var tailDetails = chunkBlock.appendTail(chunk);\n          tailDetails.skip = false; // always ignore skip, it will be set on last\n\n          details.aggregate(tailDetails);\n          masked._value += tailDetails.inserted; // get not inserted chars\n\n          var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n          if (remainChars) details.aggregate(masked.append(remainChars, {\n            tail: true\n          }));\n        } else {\n          details.aggregate(masked.append(chunk.toString(), {\n            tail: true\n          }));\n        }\n      }\n\n      return details;\n    }\n  }, {\n    key: \"shiftBefore\",\n    value: function shiftBefore(pos) {\n      if (this.from >= pos || !this.chunks.length) return '';\n      var chunkShiftPos = pos - this.from;\n      var ci = 0;\n\n      while (ci < this.chunks.length) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.shiftBefore(chunkShiftPos);\n\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          ++ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n\n        if (shiftChar) return shiftChar;\n      }\n\n      return '';\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        chunks: this.chunks.map(function (c) {\n          return c.state;\n        }),\n        from: this.from,\n        stop: this.stop,\n        blockIndex: this.blockIndex\n      };\n    },\n    set: function set(state) {\n      var chunks = state.chunks,\n          props = _objectWithoutProperties(state, [\"chunks\"]);\n\n      Object.assign(this, props);\n      this.chunks = chunks.map(function (cstate) {\n        var chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails(); // $FlowFixMe already checked above\n\n        chunk.state = cstate;\n        return chunk;\n      });\n    }\n  }]);\n\n  return ChunksTailDetails;\n}();\n\nexport default ChunksTailDetails;","map":{"version":3,"sources":["/home/rafaelle.xavier/Documentos/visitenos-form-insa/node_modules/imask/esm/masked/pattern/chunk-tail-details.js"],"names":["a","_createClass","b","_classCallCheck","c","_objectWithoutProperties","isString","ChangeDetails","ContinuousTailDetails","IMask","ChunksTailDetails","chunks","arguments","length","undefined","from","key","value","toString","map","String","join","extend","tailChunk","lastChunk","extendLast","stop","push","firstTailChunk","shift","blockIndex","appendTo","masked","MaskedPattern","tail","details","ci","skip","chunk","lastBlockIter","_mapPosToBlock","chunkBlock","index","_stops","indexOf","aggregate","_appendPlaceholder","_blocks","tailDetails","appendTail","_value","inserted","remainChars","slice","rawInserted","append","shiftBefore","pos","chunkShiftPos","shiftChar","splice","get","state","set","props","Object","assign","cstate"],"mappings":"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","sourcesContent":["import { a as _createClass, b as _classCallCheck, c as _objectWithoutProperties } from '../../_rollupPluginBabelHelpers-3c58f0e3.js';\nimport { isString } from '../../core/utils.js';\nimport ChangeDetails from '../../core/change-details.js';\nimport ContinuousTailDetails from '../../core/continuous-tail-details.js';\nimport IMask from '../../core/holder.js';\n\nvar ChunksTailDetails =\n/*#__PURE__*/\nfunction () {\n  /** */\n  function ChunksTailDetails() {\n    var chunks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    var from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n\n    _classCallCheck(this, ChunksTailDetails);\n\n    this.chunks = chunks;\n    this.from = from;\n  }\n\n  _createClass(ChunksTailDetails, [{\n    key: \"toString\",\n    value: function toString() {\n      return this.chunks.map(String).join('');\n    } // $FlowFixMe no ideas\n\n  }, {\n    key: \"extend\",\n    value: function extend(tailChunk) {\n      if (!String(tailChunk)) return;\n      if (isString(tailChunk)) tailChunk = new ContinuousTailDetails(String(tailChunk));\n      var lastChunk = this.chunks[this.chunks.length - 1];\n      var extendLast = lastChunk && ( // if stops are same or tail has no stop\n      lastChunk.stop === tailChunk.stop || tailChunk.stop == null) && // if tail chunk goes just after last chunk\n      tailChunk.from === lastChunk.from + lastChunk.toString().length;\n\n      if (tailChunk instanceof ContinuousTailDetails) {\n        // check the ability to extend previous chunk\n        if (extendLast) {\n          // extend previous chunk\n          lastChunk.extend(tailChunk.toString());\n        } else {\n          // append new chunk\n          this.chunks.push(tailChunk);\n        }\n      } else if (tailChunk instanceof ChunksTailDetails) {\n        if (tailChunk.stop == null) {\n          // unwrap floating chunks to parent, keeping `from` pos\n          var firstTailChunk;\n\n          while (tailChunk.chunks.length && tailChunk.chunks[0].stop == null) {\n            firstTailChunk = tailChunk.chunks.shift();\n            firstTailChunk.from += tailChunk.from;\n            this.extend(firstTailChunk);\n          }\n        } // if tail chunk still has value\n\n\n        if (tailChunk.toString()) {\n          // if chunks contains stops, then popup stop to container\n          tailChunk.stop = tailChunk.blockIndex;\n          this.chunks.push(tailChunk);\n        }\n      }\n    }\n  }, {\n    key: \"appendTo\",\n    value: function appendTo(masked) {\n      // $FlowFixMe\n      if (!(masked instanceof IMask.MaskedPattern)) {\n        var tail = new ContinuousTailDetails(this.toString());\n        return tail.appendTo(masked);\n      }\n\n      var details = new ChangeDetails();\n\n      for (var ci = 0; ci < this.chunks.length && !details.skip; ++ci) {\n        var chunk = this.chunks[ci];\n\n        var lastBlockIter = masked._mapPosToBlock(masked.value.length);\n\n        var stop = chunk.stop;\n        var chunkBlock = void 0;\n\n        if (stop && ( // if block not found or stop is behind lastBlock\n        !lastBlockIter || lastBlockIter.index <= stop)) {\n          if (chunk instanceof ChunksTailDetails || // for continuous block also check if stop is exist\n          masked._stops.indexOf(stop) >= 0) {\n            details.aggregate(masked._appendPlaceholder(stop));\n          }\n\n          chunkBlock = chunk instanceof ChunksTailDetails && masked._blocks[stop];\n        }\n\n        if (chunkBlock) {\n          var tailDetails = chunkBlock.appendTail(chunk);\n          tailDetails.skip = false; // always ignore skip, it will be set on last\n\n          details.aggregate(tailDetails);\n          masked._value += tailDetails.inserted; // get not inserted chars\n\n          var remainChars = chunk.toString().slice(tailDetails.rawInserted.length);\n          if (remainChars) details.aggregate(masked.append(remainChars, {\n            tail: true\n          }));\n        } else {\n          details.aggregate(masked.append(chunk.toString(), {\n            tail: true\n          }));\n        }\n      }\n      return details;\n    }\n  }, {\n    key: \"shiftBefore\",\n    value: function shiftBefore(pos) {\n      if (this.from >= pos || !this.chunks.length) return '';\n      var chunkShiftPos = pos - this.from;\n      var ci = 0;\n\n      while (ci < this.chunks.length) {\n        var chunk = this.chunks[ci];\n        var shiftChar = chunk.shiftBefore(chunkShiftPos);\n\n        if (chunk.toString()) {\n          // chunk still contains value\n          // but not shifted - means no more available chars to shift\n          if (!shiftChar) break;\n          ++ci;\n        } else {\n          // clean if chunk has no value\n          this.chunks.splice(ci, 1);\n        }\n\n        if (shiftChar) return shiftChar;\n      }\n\n      return '';\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return {\n        chunks: this.chunks.map(function (c) {\n          return c.state;\n        }),\n        from: this.from,\n        stop: this.stop,\n        blockIndex: this.blockIndex\n      };\n    },\n    set: function set(state) {\n      var chunks = state.chunks,\n          props = _objectWithoutProperties(state, [\"chunks\"]);\n\n      Object.assign(this, props);\n      this.chunks = chunks.map(function (cstate) {\n        var chunk = \"chunks\" in cstate ? new ChunksTailDetails() : new ContinuousTailDetails(); // $FlowFixMe already checked above\n\n        chunk.state = cstate;\n        return chunk;\n      });\n    }\n  }]);\n\n  return ChunksTailDetails;\n}();\n\nexport default ChunksTailDetails;\n"]},"metadata":{},"sourceType":"module"}
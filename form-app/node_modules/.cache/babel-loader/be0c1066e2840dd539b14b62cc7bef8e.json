{"ast":null,"code":"import { d as _inherits, a as _createClass, b as _classCallCheck, e as _possibleConstructorReturn, f as _getPrototypeOf, g as _get, c as _objectWithoutProperties, h as _set } from '../_rollupPluginBabelHelpers-3c58f0e3.js';\nimport { forceDirection, DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport '../core/continuous-tail-details.js';\nimport IMask from '../core/holder.js';\nimport Masked from './base.js';\nimport createMask from './factory.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\n/**\r\n  Pattern mask\r\n  @param {Object} opts\r\n  @param {Object} opts.blocks\r\n  @param {Object} opts.definitions\r\n  @param {string} opts.placeholderChar\r\n  @param {boolean} opts.lazy\r\n*/\n\nvar MaskedPattern = /*#__PURE__*/function (_Masked) {\n  _inherits(MaskedPattern, _Masked);\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Show placeholder only when needed */\n\n\n  function MaskedPattern() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MaskedPattern); // TODO type $Shape<MaskedPatternOptions>={} does not work\n\n\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedPattern).call(this, Object.assign({}, MaskedPattern.DEFAULTS, {}, opts)));\n  }\n  /**\r\n    @override\r\n    @param {Object} opts\r\n  */\n\n\n  _createClass(MaskedPattern, [{\n    key: \"_update\",\n    value: function _update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"_update\", this).call(this, opts);\n\n      this._rebuildMask();\n    }\n    /** */\n\n  }, {\n    key: \"_rebuildMask\",\n    value: function _rebuildMask() {\n      var _this = this;\n\n      var defs = this.definitions;\n      this._blocks = [];\n      this._stops = [];\n      this._maskedBlocks = {};\n      var pattern = this.mask;\n      if (!pattern || !defs) return;\n      var unmaskingBlock = false;\n      var optionalBlock = false;\n\n      for (var i = 0; i < pattern.length; ++i) {\n        if (this.blocks) {\n          var _ret = function () {\n            var p = pattern.slice(i);\n            var bNames = Object.keys(_this.blocks).filter(function (bName) {\n              return p.indexOf(bName) === 0;\n            }); // order by key length\n\n            bNames.sort(function (a, b) {\n              return b.length - a.length;\n            }); // use block name with max length\n\n            var bName = bNames[0];\n\n            if (bName) {\n              var maskedBlock = createMask(Object.assign({\n                parent: _this,\n                lazy: _this.lazy,\n                placeholderChar: _this.placeholderChar,\n                overwrite: _this.overwrite\n              }, _this.blocks[bName]));\n\n              if (maskedBlock) {\n                _this._blocks.push(maskedBlock); // store block index\n\n\n                if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];\n\n                _this._maskedBlocks[bName].push(_this._blocks.length - 1);\n              }\n\n              i += bName.length - 1;\n              return \"continue\";\n            }\n          }();\n\n          if (_ret === \"continue\") continue;\n        }\n\n        var char = pattern[i];\n\n        var _isInput = char in defs;\n\n        if (char === MaskedPattern.STOP_CHAR) {\n          this._stops.push(this._blocks.length);\n\n          continue;\n        }\n\n        if (char === '{' || char === '}') {\n          unmaskingBlock = !unmaskingBlock;\n          continue;\n        }\n\n        if (char === '[' || char === ']') {\n          optionalBlock = !optionalBlock;\n          continue;\n        }\n\n        if (char === MaskedPattern.ESCAPE_CHAR) {\n          ++i;\n          char = pattern[i];\n          if (!char) break;\n          _isInput = false;\n        }\n\n        var def = _isInput ? new PatternInputDefinition({\n          parent: this,\n          lazy: this.lazy,\n          placeholderChar: this.placeholderChar,\n          mask: defs[char],\n          isOptional: optionalBlock\n        }) : new PatternFixedDefinition({\n          char: char,\n          isUnmasking: unmaskingBlock\n        });\n\n        this._blocks.push(def);\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"reset\",\n\n    /**\r\n      @override\r\n    */\n    value: function reset() {\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"reset\", this).call(this);\n\n      this._blocks.forEach(function (b) {\n        return b.reset();\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"doCommit\",\n\n    /**\r\n      @override\r\n    */\n    value: function doCommit() {\n      this._blocks.forEach(function (b) {\n        return b.doCommit();\n      });\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"doCommit\", this).call(this);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"appendTail\",\n\n    /**\r\n      @override\r\n    */\n    value: function appendTail(tail) {\n      return _get(_getPrototypeOf(MaskedPattern.prototype), \"appendTail\", this).call(this, tail).aggregate(this._appendPlaceholder());\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      ch = this.doPrepare(ch, flags);\n\n      var blockIter = this._mapPosToBlock(this.value.length);\n\n      var details = new ChangeDetails();\n      if (!blockIter) return details;\n\n      for (var bi = blockIter.index;; ++bi) {\n        var _block = this._blocks[bi];\n        if (!_block) break;\n\n        var blockDetails = _block._appendChar(ch, flags);\n\n        var skip = blockDetails.skip;\n        details.aggregate(blockDetails);\n        if (skip || blockDetails.rawInserted) break; // go next char\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var _this2 = this;\n\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var chunkTail = new ChunksTailDetails();\n      if (fromPos === toPos) return chunkTail;\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {\n        var blockChunk = b.extractTail(bFromPos, bToPos);\n        blockChunk.stop = _this2._findStopBefore(bi);\n        blockChunk.from = _this2._blockStartPos(bi);\n        if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n        chunkTail.extend(blockChunk);\n      });\n\n      return chunkTail;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (fromPos === toPos) return '';\n      var input = '';\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {\n        input += b.extractInput(fromPos, toPos, flags);\n      });\n\n      return input;\n    }\n  }, {\n    key: \"_findStopBefore\",\n    value: function _findStopBefore(blockIndex) {\n      var stopBefore;\n\n      for (var si = 0; si < this._stops.length; ++si) {\n        var stop = this._stops[si];\n        if (stop <= blockIndex) stopBefore = stop;else break;\n      }\n\n      return stopBefore;\n    }\n    /** Appends placeholder depending on laziness */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder(toBlockIndex) {\n      var _this3 = this;\n\n      var details = new ChangeDetails();\n      if (this.lazy && toBlockIndex == null) return details;\n\n      var startBlockIter = this._mapPosToBlock(this.value.length);\n\n      if (!startBlockIter) return details;\n      var startBlockIndex = startBlockIter.index;\n      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n\n      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {\n        if (!b.lazy || toBlockIndex != null) {\n          // $FlowFixMe `_blocks` may not be present\n          var args = b._blocks != null ? [b._blocks.length] : [];\n\n          var bDetails = b._appendPlaceholder.apply(b, args);\n\n          _this3._value += bDetails.inserted;\n          details.aggregate(bDetails);\n        }\n      });\n\n      return details;\n    }\n    /** Finds block in pos */\n\n  }, {\n    key: \"_mapPosToBlock\",\n    value: function _mapPosToBlock(pos) {\n      var accVal = '';\n\n      for (var bi = 0; bi < this._blocks.length; ++bi) {\n        var _block2 = this._blocks[bi];\n        var blockStartPos = accVal.length;\n        accVal += _block2.value;\n\n        if (pos <= accVal.length) {\n          return {\n            index: bi,\n            offset: pos - blockStartPos\n          };\n        }\n      }\n    }\n    /** */\n\n  }, {\n    key: \"_blockStartPos\",\n    value: function _blockStartPos(blockIndex) {\n      return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {\n        return pos += b.value.length;\n      }, 0);\n    }\n    /** */\n\n  }, {\n    key: \"_forEachBlocksInRange\",\n    value: function _forEachBlocksInRange(fromPos) {\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var fn = arguments.length > 2 ? arguments[2] : undefined;\n\n      var fromBlockIter = this._mapPosToBlock(fromPos);\n\n      if (fromBlockIter) {\n        var toBlockIter = this._mapPosToBlock(toPos); // process first block\n\n\n        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n        var fromBlockStartPos = fromBlockIter.offset;\n        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n\n        if (toBlockIter && !isSameBlock) {\n          // process intermediate blocks\n          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n            fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n          } // process last block\n\n\n          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n        }\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n      var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), \"remove\", this).call(this, fromPos, toPos);\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {\n        removeDetails.aggregate(b.remove(bFromPos, bToPos));\n      });\n\n      return removeDetails;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE; // TODO refactor - extract alignblock\n\n      var beginBlockData = this._mapPosToBlock(cursorPos) || {\n        index: 0,\n        offset: 0\n      };\n      var beginBlockOffset = beginBlockData.offset,\n          beginBlockIndex = beginBlockData.index;\n      var beginBlock = this._blocks[beginBlockIndex];\n      if (!beginBlock) return cursorPos;\n      var beginBlockCursorPos = beginBlockOffset; // if position inside block - try to adjust it\n\n      if (beginBlockCursorPos !== 0 && beginBlockCursorPos < beginBlock.value.length) {\n        beginBlockCursorPos = beginBlock.nearestInputPos(beginBlockOffset, forceDirection(direction));\n      }\n\n      var cursorAtRight = beginBlockCursorPos === beginBlock.value.length;\n      var cursorAtLeft = beginBlockCursorPos === 0; //  cursor is INSIDE first block (not at bounds)\n\n      if (!cursorAtLeft && !cursorAtRight) return this._blockStartPos(beginBlockIndex) + beginBlockCursorPos;\n      var searchBlockIndex = cursorAtRight ? beginBlockIndex + 1 : beginBlockIndex;\n\n      if (direction === DIRECTION.NONE) {\n        // NONE direction used to calculate start input position if no chars were removed\n        // FOR NONE:\n        // -\n        // input|any\n        // ->\n        //  any|input\n        // <-\n        //  filled-input|any\n        // check if first block at left is input\n        if (searchBlockIndex > 0) {\n          var blockIndexAtLeft = searchBlockIndex - 1;\n          var blockAtLeft = this._blocks[blockIndexAtLeft];\n          var blockInputPos = blockAtLeft.nearestInputPos(0, DIRECTION.NONE); // is input\n\n          if (!blockAtLeft.value.length || blockInputPos !== blockAtLeft.value.length) {\n            return this._blockStartPos(searchBlockIndex);\n          }\n        } // ->\n\n\n        var firstInputAtRight = searchBlockIndex;\n\n        for (var bi = firstInputAtRight; bi < this._blocks.length; ++bi) {\n          var blockAtRight = this._blocks[bi];\n\n          var _blockInputPos = blockAtRight.nearestInputPos(0, DIRECTION.NONE);\n\n          if (!blockAtRight.value.length || _blockInputPos !== blockAtRight.value.length) {\n            return this._blockStartPos(bi) + _blockInputPos;\n          }\n        } // <-\n        // find first non-fixed symbol\n\n\n        for (var _bi = searchBlockIndex - 1; _bi >= 0; --_bi) {\n          var _block3 = this._blocks[_bi];\n\n          var _blockInputPos2 = _block3.nearestInputPos(0, DIRECTION.NONE); // is input\n\n\n          if (!_block3.value.length || _blockInputPos2 !== _block3.value.length) {\n            return this._blockStartPos(_bi) + _block3.value.length;\n          }\n        }\n\n        return cursorPos;\n      }\n\n      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n        // -\n        //  any|filled-input\n        // <-\n        //  any|first not empty is not-len-aligned\n        //  not-0-aligned|any\n        // ->\n        //  any|not-len-aligned or end\n        // check if first block at right is filled input\n        var firstFilledBlockIndexAtRight;\n\n        for (var _bi2 = searchBlockIndex; _bi2 < this._blocks.length; ++_bi2) {\n          if (this._blocks[_bi2].value) {\n            firstFilledBlockIndexAtRight = _bi2;\n            break;\n          }\n        }\n\n        if (firstFilledBlockIndexAtRight != null) {\n          var filledBlock = this._blocks[firstFilledBlockIndexAtRight];\n\n          var _blockInputPos3 = filledBlock.nearestInputPos(0, DIRECTION.RIGHT);\n\n          if (_blockInputPos3 === 0 && filledBlock.unmaskedValue.length) {\n            // filled block is input\n            return this._blockStartPos(firstFilledBlockIndexAtRight) + _blockInputPos3;\n          }\n        } // <-\n        // find this vars\n\n\n        var firstFilledInputBlockIndex = -1;\n        var firstEmptyInputBlockIndex; // TODO consider nested empty inputs\n\n        for (var _bi3 = searchBlockIndex - 1; _bi3 >= 0; --_bi3) {\n          var _block4 = this._blocks[_bi3];\n\n          var _blockInputPos4 = _block4.nearestInputPos(_block4.value.length, DIRECTION.FORCE_LEFT);\n\n          if (!_block4.value || _blockInputPos4 !== 0) firstEmptyInputBlockIndex = _bi3;\n\n          if (_blockInputPos4 !== 0) {\n            if (_blockInputPos4 !== _block4.value.length) {\n              // aligned inside block - return immediately\n              return this._blockStartPos(_bi3) + _blockInputPos4;\n            } else {\n              // found filled\n              firstFilledInputBlockIndex = _bi3;\n              break;\n            }\n          }\n        }\n\n        if (direction === DIRECTION.LEFT) {\n          // try find first empty input before start searching position only when not forced\n          for (var _bi4 = firstFilledInputBlockIndex + 1; _bi4 <= Math.min(searchBlockIndex, this._blocks.length - 1); ++_bi4) {\n            var _block5 = this._blocks[_bi4];\n\n            var _blockInputPos5 = _block5.nearestInputPos(0, DIRECTION.NONE);\n\n            var blockAlignedPos = this._blockStartPos(_bi4) + _blockInputPos5;\n\n            if (blockAlignedPos > cursorPos) break; // if block is not lazy input\n\n            if (_blockInputPos5 !== _block5.value.length) return blockAlignedPos;\n          }\n        } // process overflow\n\n\n        if (firstFilledInputBlockIndex >= 0) {\n          return this._blockStartPos(firstFilledInputBlockIndex) + this._blocks[firstFilledInputBlockIndex].value.length;\n        } // for lazy if has aligned left inside fixed and has came to the start - use start position\n\n\n        if (direction === DIRECTION.FORCE_LEFT || this.lazy && !this.extractInput() && !isInput(this._blocks[searchBlockIndex])) {\n          return 0;\n        }\n\n        if (firstEmptyInputBlockIndex != null) {\n          return this._blockStartPos(firstEmptyInputBlockIndex);\n        } // find first input\n\n\n        for (var _bi5 = searchBlockIndex; _bi5 < this._blocks.length; ++_bi5) {\n          var _block6 = this._blocks[_bi5];\n\n          var _blockInputPos6 = _block6.nearestInputPos(0, DIRECTION.NONE); // is input\n\n\n          if (!_block6.value.length || _blockInputPos6 !== _block6.value.length) {\n            return this._blockStartPos(_bi5) + _blockInputPos6;\n          }\n        }\n\n        return 0;\n      }\n\n      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n        // ->\n        //  any|not-len-aligned and filled\n        //  any|not-len-aligned\n        // <-\n        //  not-0-aligned or start|any\n        var firstInputBlockAlignedIndex;\n        var firstInputBlockAlignedPos;\n\n        for (var _bi6 = searchBlockIndex; _bi6 < this._blocks.length; ++_bi6) {\n          var _block7 = this._blocks[_bi6];\n\n          var _blockInputPos7 = _block7.nearestInputPos(0, DIRECTION.NONE);\n\n          if (_blockInputPos7 !== _block7.value.length) {\n            firstInputBlockAlignedPos = this._blockStartPos(_bi6) + _blockInputPos7;\n            firstInputBlockAlignedIndex = _bi6;\n            break;\n          }\n        }\n\n        if (firstInputBlockAlignedIndex != null && firstInputBlockAlignedPos != null) {\n          for (var _bi7 = firstInputBlockAlignedIndex; _bi7 < this._blocks.length; ++_bi7) {\n            var _block8 = this._blocks[_bi7];\n\n            var _blockInputPos8 = _block8.nearestInputPos(0, DIRECTION.FORCE_RIGHT);\n\n            if (_blockInputPos8 !== _block8.value.length) {\n              return this._blockStartPos(_bi7) + _blockInputPos8;\n            }\n          }\n\n          return direction === DIRECTION.FORCE_RIGHT ? this.value.length : firstInputBlockAlignedPos;\n        }\n\n        for (var _bi8 = Math.min(searchBlockIndex, this._blocks.length - 1); _bi8 >= 0; --_bi8) {\n          var _block9 = this._blocks[_bi8];\n\n          var _blockInputPos9 = _block9.nearestInputPos(_block9.value.length, DIRECTION.LEFT);\n\n          if (_blockInputPos9 !== 0) {\n            var alignedPos = this._blockStartPos(_bi8) + _blockInputPos9;\n\n            if (alignedPos >= cursorPos) return alignedPos;\n            break;\n          }\n        }\n      }\n\n      return cursorPos;\n    }\n    /** Get block by name */\n\n  }, {\n    key: \"maskedBlock\",\n    value: function maskedBlock(name) {\n      return this.maskedBlocks(name)[0];\n    }\n    /** Get all blocks by name */\n\n  }, {\n    key: \"maskedBlocks\",\n    value: function maskedBlocks(name) {\n      var _this4 = this;\n\n      var indices = this._maskedBlocks[name];\n      if (!indices) return [];\n      return indices.map(function (gi) {\n        return _this4._blocks[gi];\n      });\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), \"state\", this), {\n        _blocks: this._blocks.map(function (b) {\n          return b.state;\n        })\n      });\n    },\n    set: function set(state) {\n      var _blocks = state._blocks,\n          maskedState = _objectWithoutProperties(state, [\"_blocks\"]);\n\n      this._blocks.forEach(function (b, bi) {\n        return b.state = _blocks[bi];\n      });\n\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"state\", maskedState, this, true);\n    }\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isComplete;\n      });\n    }\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this._blocks.reduce(function (str, b) {\n        return str += b.unmaskedValue;\n      }, '');\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"unmaskedValue\", unmaskedValue, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      // TODO return _value when not in change?\n      return this._blocks.reduce(function (str, b) {\n        return str += b.value;\n      }, '');\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"value\", value, this, true);\n    }\n  }]);\n\n  return MaskedPattern;\n}(Masked);\n\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\n\nfunction isInput(block) {\n  if (!block) return false;\n  var value = block.value;\n  return !value || block.nearestInputPos(0, DIRECTION.NONE) !== value.length;\n}\n\nIMask.MaskedPattern = MaskedPattern;\nexport default MaskedPattern;","map":{"version":3,"sources":["/home/rafaelle.xavier/Documentos/visitenos-form-insa/node_modules/imask/esm/masked/pattern.js"],"names":["d","_inherits","a","_createClass","b","_classCallCheck","e","_possibleConstructorReturn","f","_getPrototypeOf","g","_get","c","_objectWithoutProperties","h","_set","forceDirection","DIRECTION","ChangeDetails","IMask","Masked","createMask","PatternInputDefinition","DEFAULT_INPUT_DEFINITIONS","PatternFixedDefinition","ChunksTailDetails","MaskedPattern","_Masked","opts","arguments","length","undefined","definitions","Object","assign","call","DEFAULTS","key","value","_update","prototype","_rebuildMask","_this","defs","_blocks","_stops","_maskedBlocks","pattern","mask","unmaskingBlock","optionalBlock","i","blocks","_ret","p","slice","bNames","keys","filter","bName","indexOf","sort","maskedBlock","parent","lazy","placeholderChar","overwrite","push","char","_isInput","STOP_CHAR","ESCAPE_CHAR","def","isOptional","isUnmasking","reset","forEach","doCommit","appendTail","tail","aggregate","_appendPlaceholder","_appendCharRaw","ch","flags","doPrepare","blockIter","_mapPosToBlock","details","bi","index","_block","blockDetails","_appendChar","skip","rawInserted","extractTail","_this2","fromPos","toPos","chunkTail","_forEachBlocksInRange","bFromPos","bToPos","blockChunk","stop","_findStopBefore","from","_blockStartPos","blockIndex","extend","extractInput","input","_","stopBefore","si","toBlockIndex","_this3","startBlockIter","startBlockIndex","endBlockIndex","args","bDetails","apply","_value","inserted","pos","accVal","_block2","blockStartPos","offset","reduce","fn","fromBlockIter","toBlockIter","isSameBlock","fromBlockStartPos","fromBlockEndPos","remove","removeDetails","nearestInputPos","cursorPos","direction","NONE","beginBlockData","beginBlockOffset","beginBlockIndex","beginBlock","beginBlockCursorPos","cursorAtRight","cursorAtLeft","searchBlockIndex","blockIndexAtLeft","blockAtLeft","blockInputPos","firstInputAtRight","blockAtRight","_blockInputPos","_bi","_block3","_blockInputPos2","LEFT","FORCE_LEFT","firstFilledBlockIndexAtRight","_bi2","filledBlock","_blockInputPos3","RIGHT","unmaskedValue","firstFilledInputBlockIndex","firstEmptyInputBlockIndex","_bi3","_block4","_blockInputPos4","_bi4","Math","min","_block5","_blockInputPos5","blockAlignedPos","isInput","_bi5","_block6","_blockInputPos6","FORCE_RIGHT","firstInputBlockAlignedIndex","firstInputBlockAlignedPos","_bi6","_block7","_blockInputPos7","_bi7","_block8","_blockInputPos8","_bi8","_block9","_blockInputPos9","alignedPos","name","maskedBlocks","_this4","indices","map","gi","get","state","set","maskedState","every","isComplete","str","InputDefinition","FixedDefinition","block"],"mappings":"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","sourcesContent":["import { d as _inherits, a as _createClass, b as _classCallCheck, e as _possibleConstructorReturn, f as _getPrototypeOf, g as _get, c as _objectWithoutProperties, h as _set } from '../_rollupPluginBabelHelpers-3c58f0e3.js';\nimport { forceDirection, DIRECTION } from '../core/utils.js';\nimport ChangeDetails from '../core/change-details.js';\nimport '../core/continuous-tail-details.js';\nimport IMask from '../core/holder.js';\nimport Masked from './base.js';\nimport createMask from './factory.js';\nimport PatternInputDefinition, { DEFAULT_INPUT_DEFINITIONS } from './pattern/input-definition.js';\nimport PatternFixedDefinition from './pattern/fixed-definition.js';\nimport ChunksTailDetails from './pattern/chunk-tail-details.js';\n\n/**\r\n  Pattern mask\r\n  @param {Object} opts\r\n  @param {Object} opts.blocks\r\n  @param {Object} opts.definitions\r\n  @param {string} opts.placeholderChar\r\n  @param {boolean} opts.lazy\r\n*/\nvar MaskedPattern =\n/*#__PURE__*/\nfunction (_Masked) {\n  _inherits(MaskedPattern, _Masked);\n\n  /** */\n\n  /** */\n\n  /** Single char for empty input */\n\n  /** Show placeholder only when needed */\n  function MaskedPattern() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, MaskedPattern);\n\n    // TODO type $Shape<MaskedPatternOptions>={} does not work\n    opts.definitions = Object.assign({}, DEFAULT_INPUT_DEFINITIONS, opts.definitions);\n    return _possibleConstructorReturn(this, _getPrototypeOf(MaskedPattern).call(this, Object.assign({}, MaskedPattern.DEFAULTS, {}, opts)));\n  }\n  /**\r\n    @override\r\n    @param {Object} opts\r\n  */\n\n\n  _createClass(MaskedPattern, [{\n    key: \"_update\",\n    value: function _update() {\n      var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      opts.definitions = Object.assign({}, this.definitions, opts.definitions);\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"_update\", this).call(this, opts);\n\n      this._rebuildMask();\n    }\n    /** */\n\n  }, {\n    key: \"_rebuildMask\",\n    value: function _rebuildMask() {\n      var _this = this;\n\n      var defs = this.definitions;\n      this._blocks = [];\n      this._stops = [];\n      this._maskedBlocks = {};\n      var pattern = this.mask;\n      if (!pattern || !defs) return;\n      var unmaskingBlock = false;\n      var optionalBlock = false;\n\n      for (var i = 0; i < pattern.length; ++i) {\n        if (this.blocks) {\n          var _ret = function () {\n            var p = pattern.slice(i);\n            var bNames = Object.keys(_this.blocks).filter(function (bName) {\n              return p.indexOf(bName) === 0;\n            }); // order by key length\n\n            bNames.sort(function (a, b) {\n              return b.length - a.length;\n            }); // use block name with max length\n\n            var bName = bNames[0];\n\n            if (bName) {\n              var maskedBlock = createMask(Object.assign({\n                parent: _this,\n                lazy: _this.lazy,\n                placeholderChar: _this.placeholderChar,\n                overwrite: _this.overwrite\n              }, _this.blocks[bName]));\n\n              if (maskedBlock) {\n                _this._blocks.push(maskedBlock); // store block index\n\n\n                if (!_this._maskedBlocks[bName]) _this._maskedBlocks[bName] = [];\n\n                _this._maskedBlocks[bName].push(_this._blocks.length - 1);\n              }\n\n              i += bName.length - 1;\n              return \"continue\";\n            }\n          }();\n\n          if (_ret === \"continue\") continue;\n        }\n\n        var char = pattern[i];\n\n        var _isInput = char in defs;\n\n        if (char === MaskedPattern.STOP_CHAR) {\n          this._stops.push(this._blocks.length);\n\n          continue;\n        }\n\n        if (char === '{' || char === '}') {\n          unmaskingBlock = !unmaskingBlock;\n          continue;\n        }\n\n        if (char === '[' || char === ']') {\n          optionalBlock = !optionalBlock;\n          continue;\n        }\n\n        if (char === MaskedPattern.ESCAPE_CHAR) {\n          ++i;\n          char = pattern[i];\n          if (!char) break;\n          _isInput = false;\n        }\n\n        var def = _isInput ? new PatternInputDefinition({\n          parent: this,\n          lazy: this.lazy,\n          placeholderChar: this.placeholderChar,\n          mask: defs[char],\n          isOptional: optionalBlock\n        }) : new PatternFixedDefinition({\n          char: char,\n          isUnmasking: unmaskingBlock\n        });\n\n        this._blocks.push(def);\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"reset\",\n\n    /**\r\n      @override\r\n    */\n    value: function reset() {\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"reset\", this).call(this);\n\n      this._blocks.forEach(function (b) {\n        return b.reset();\n      });\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"doCommit\",\n\n    /**\r\n      @override\r\n    */\n    value: function doCommit() {\n      this._blocks.forEach(function (b) {\n        return b.doCommit();\n      });\n\n      _get(_getPrototypeOf(MaskedPattern.prototype), \"doCommit\", this).call(this);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"appendTail\",\n\n    /**\r\n      @override\r\n    */\n    value: function appendTail(tail) {\n      return _get(_getPrototypeOf(MaskedPattern.prototype), \"appendTail\", this).call(this, tail).aggregate(this._appendPlaceholder());\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"_appendCharRaw\",\n    value: function _appendCharRaw(ch) {\n      var flags = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      ch = this.doPrepare(ch, flags);\n\n      var blockIter = this._mapPosToBlock(this.value.length);\n\n      var details = new ChangeDetails();\n      if (!blockIter) return details;\n\n      for (var bi = blockIter.index;; ++bi) {\n        var _block = this._blocks[bi];\n        if (!_block) break;\n\n        var blockDetails = _block._appendChar(ch, flags);\n\n        var skip = blockDetails.skip;\n        details.aggregate(blockDetails);\n        if (skip || blockDetails.rawInserted) break; // go next char\n      }\n\n      return details;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"extractTail\",\n    value: function extractTail() {\n      var _this2 = this;\n\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var chunkTail = new ChunksTailDetails();\n      if (fromPos === toPos) return chunkTail;\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, bi, bFromPos, bToPos) {\n        var blockChunk = b.extractTail(bFromPos, bToPos);\n        blockChunk.stop = _this2._findStopBefore(bi);\n        blockChunk.from = _this2._blockStartPos(bi);\n        if (blockChunk instanceof ChunksTailDetails) blockChunk.blockIndex = bi;\n        chunkTail.extend(blockChunk);\n      });\n\n      return chunkTail;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"extractInput\",\n    value: function extractInput() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var flags = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      if (fromPos === toPos) return '';\n      var input = '';\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, fromPos, toPos) {\n        input += b.extractInput(fromPos, toPos, flags);\n      });\n\n      return input;\n    }\n  }, {\n    key: \"_findStopBefore\",\n    value: function _findStopBefore(blockIndex) {\n      var stopBefore;\n\n      for (var si = 0; si < this._stops.length; ++si) {\n        var stop = this._stops[si];\n        if (stop <= blockIndex) stopBefore = stop;else break;\n      }\n\n      return stopBefore;\n    }\n    /** Appends placeholder depending on laziness */\n\n  }, {\n    key: \"_appendPlaceholder\",\n    value: function _appendPlaceholder(toBlockIndex) {\n      var _this3 = this;\n\n      var details = new ChangeDetails();\n      if (this.lazy && toBlockIndex == null) return details;\n\n      var startBlockIter = this._mapPosToBlock(this.value.length);\n\n      if (!startBlockIter) return details;\n      var startBlockIndex = startBlockIter.index;\n      var endBlockIndex = toBlockIndex != null ? toBlockIndex : this._blocks.length;\n\n      this._blocks.slice(startBlockIndex, endBlockIndex).forEach(function (b) {\n        if (!b.lazy || toBlockIndex != null) {\n          // $FlowFixMe `_blocks` may not be present\n          var args = b._blocks != null ? [b._blocks.length] : [];\n\n          var bDetails = b._appendPlaceholder.apply(b, args);\n\n          _this3._value += bDetails.inserted;\n          details.aggregate(bDetails);\n        }\n      });\n\n      return details;\n    }\n    /** Finds block in pos */\n\n  }, {\n    key: \"_mapPosToBlock\",\n    value: function _mapPosToBlock(pos) {\n      var accVal = '';\n\n      for (var bi = 0; bi < this._blocks.length; ++bi) {\n        var _block2 = this._blocks[bi];\n        var blockStartPos = accVal.length;\n        accVal += _block2.value;\n\n        if (pos <= accVal.length) {\n          return {\n            index: bi,\n            offset: pos - blockStartPos\n          };\n        }\n      }\n    }\n    /** */\n\n  }, {\n    key: \"_blockStartPos\",\n    value: function _blockStartPos(blockIndex) {\n      return this._blocks.slice(0, blockIndex).reduce(function (pos, b) {\n        return pos += b.value.length;\n      }, 0);\n    }\n    /** */\n\n  }, {\n    key: \"_forEachBlocksInRange\",\n    value: function _forEachBlocksInRange(fromPos) {\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n      var fn = arguments.length > 2 ? arguments[2] : undefined;\n\n      var fromBlockIter = this._mapPosToBlock(fromPos);\n\n      if (fromBlockIter) {\n        var toBlockIter = this._mapPosToBlock(toPos); // process first block\n\n\n        var isSameBlock = toBlockIter && fromBlockIter.index === toBlockIter.index;\n        var fromBlockStartPos = fromBlockIter.offset;\n        var fromBlockEndPos = toBlockIter && isSameBlock ? toBlockIter.offset : this._blocks[fromBlockIter.index].value.length;\n        fn(this._blocks[fromBlockIter.index], fromBlockIter.index, fromBlockStartPos, fromBlockEndPos);\n\n        if (toBlockIter && !isSameBlock) {\n          // process intermediate blocks\n          for (var bi = fromBlockIter.index + 1; bi < toBlockIter.index; ++bi) {\n            fn(this._blocks[bi], bi, 0, this._blocks[bi].value.length);\n          } // process last block\n\n\n          fn(this._blocks[toBlockIter.index], toBlockIter.index, 0, toBlockIter.offset);\n        }\n      }\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var fromPos = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var toPos = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.value.length;\n\n      var removeDetails = _get(_getPrototypeOf(MaskedPattern.prototype), \"remove\", this).call(this, fromPos, toPos);\n\n      this._forEachBlocksInRange(fromPos, toPos, function (b, _, bFromPos, bToPos) {\n        removeDetails.aggregate(b.remove(bFromPos, bToPos));\n      });\n\n      return removeDetails;\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"nearestInputPos\",\n    value: function nearestInputPos(cursorPos) {\n      var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : DIRECTION.NONE;\n      // TODO refactor - extract alignblock\n      var beginBlockData = this._mapPosToBlock(cursorPos) || {\n        index: 0,\n        offset: 0\n      };\n      var beginBlockOffset = beginBlockData.offset,\n          beginBlockIndex = beginBlockData.index;\n      var beginBlock = this._blocks[beginBlockIndex];\n      if (!beginBlock) return cursorPos;\n      var beginBlockCursorPos = beginBlockOffset; // if position inside block - try to adjust it\n\n      if (beginBlockCursorPos !== 0 && beginBlockCursorPos < beginBlock.value.length) {\n        beginBlockCursorPos = beginBlock.nearestInputPos(beginBlockOffset, forceDirection(direction));\n      }\n\n      var cursorAtRight = beginBlockCursorPos === beginBlock.value.length;\n      var cursorAtLeft = beginBlockCursorPos === 0; //  cursor is INSIDE first block (not at bounds)\n\n      if (!cursorAtLeft && !cursorAtRight) return this._blockStartPos(beginBlockIndex) + beginBlockCursorPos;\n      var searchBlockIndex = cursorAtRight ? beginBlockIndex + 1 : beginBlockIndex;\n\n      if (direction === DIRECTION.NONE) {\n        // NONE direction used to calculate start input position if no chars were removed\n        // FOR NONE:\n        // -\n        // input|any\n        // ->\n        //  any|input\n        // <-\n        //  filled-input|any\n        // check if first block at left is input\n        if (searchBlockIndex > 0) {\n          var blockIndexAtLeft = searchBlockIndex - 1;\n          var blockAtLeft = this._blocks[blockIndexAtLeft];\n          var blockInputPos = blockAtLeft.nearestInputPos(0, DIRECTION.NONE); // is input\n\n          if (!blockAtLeft.value.length || blockInputPos !== blockAtLeft.value.length) {\n            return this._blockStartPos(searchBlockIndex);\n          }\n        } // ->\n\n\n        var firstInputAtRight = searchBlockIndex;\n\n        for (var bi = firstInputAtRight; bi < this._blocks.length; ++bi) {\n          var blockAtRight = this._blocks[bi];\n\n          var _blockInputPos = blockAtRight.nearestInputPos(0, DIRECTION.NONE);\n\n          if (!blockAtRight.value.length || _blockInputPos !== blockAtRight.value.length) {\n            return this._blockStartPos(bi) + _blockInputPos;\n          }\n        } // <-\n        // find first non-fixed symbol\n\n\n        for (var _bi = searchBlockIndex - 1; _bi >= 0; --_bi) {\n          var _block3 = this._blocks[_bi];\n\n          var _blockInputPos2 = _block3.nearestInputPos(0, DIRECTION.NONE); // is input\n\n\n          if (!_block3.value.length || _blockInputPos2 !== _block3.value.length) {\n            return this._blockStartPos(_bi) + _block3.value.length;\n          }\n        }\n\n        return cursorPos;\n      }\n\n      if (direction === DIRECTION.LEFT || direction === DIRECTION.FORCE_LEFT) {\n        // -\n        //  any|filled-input\n        // <-\n        //  any|first not empty is not-len-aligned\n        //  not-0-aligned|any\n        // ->\n        //  any|not-len-aligned or end\n        // check if first block at right is filled input\n        var firstFilledBlockIndexAtRight;\n\n        for (var _bi2 = searchBlockIndex; _bi2 < this._blocks.length; ++_bi2) {\n          if (this._blocks[_bi2].value) {\n            firstFilledBlockIndexAtRight = _bi2;\n            break;\n          }\n        }\n\n        if (firstFilledBlockIndexAtRight != null) {\n          var filledBlock = this._blocks[firstFilledBlockIndexAtRight];\n\n          var _blockInputPos3 = filledBlock.nearestInputPos(0, DIRECTION.RIGHT);\n\n          if (_blockInputPos3 === 0 && filledBlock.unmaskedValue.length) {\n            // filled block is input\n            return this._blockStartPos(firstFilledBlockIndexAtRight) + _blockInputPos3;\n          }\n        } // <-\n        // find this vars\n\n\n        var firstFilledInputBlockIndex = -1;\n        var firstEmptyInputBlockIndex; // TODO consider nested empty inputs\n\n        for (var _bi3 = searchBlockIndex - 1; _bi3 >= 0; --_bi3) {\n          var _block4 = this._blocks[_bi3];\n\n          var _blockInputPos4 = _block4.nearestInputPos(_block4.value.length, DIRECTION.FORCE_LEFT);\n\n          if (!_block4.value || _blockInputPos4 !== 0) firstEmptyInputBlockIndex = _bi3;\n\n          if (_blockInputPos4 !== 0) {\n            if (_blockInputPos4 !== _block4.value.length) {\n              // aligned inside block - return immediately\n              return this._blockStartPos(_bi3) + _blockInputPos4;\n            } else {\n              // found filled\n              firstFilledInputBlockIndex = _bi3;\n              break;\n            }\n          }\n        }\n\n        if (direction === DIRECTION.LEFT) {\n          // try find first empty input before start searching position only when not forced\n          for (var _bi4 = firstFilledInputBlockIndex + 1; _bi4 <= Math.min(searchBlockIndex, this._blocks.length - 1); ++_bi4) {\n            var _block5 = this._blocks[_bi4];\n\n            var _blockInputPos5 = _block5.nearestInputPos(0, DIRECTION.NONE);\n\n            var blockAlignedPos = this._blockStartPos(_bi4) + _blockInputPos5;\n\n            if (blockAlignedPos > cursorPos) break; // if block is not lazy input\n\n            if (_blockInputPos5 !== _block5.value.length) return blockAlignedPos;\n          }\n        } // process overflow\n\n\n        if (firstFilledInputBlockIndex >= 0) {\n          return this._blockStartPos(firstFilledInputBlockIndex) + this._blocks[firstFilledInputBlockIndex].value.length;\n        } // for lazy if has aligned left inside fixed and has came to the start - use start position\n\n\n        if (direction === DIRECTION.FORCE_LEFT || this.lazy && !this.extractInput() && !isInput(this._blocks[searchBlockIndex])) {\n          return 0;\n        }\n\n        if (firstEmptyInputBlockIndex != null) {\n          return this._blockStartPos(firstEmptyInputBlockIndex);\n        } // find first input\n\n\n        for (var _bi5 = searchBlockIndex; _bi5 < this._blocks.length; ++_bi5) {\n          var _block6 = this._blocks[_bi5];\n\n          var _blockInputPos6 = _block6.nearestInputPos(0, DIRECTION.NONE); // is input\n\n\n          if (!_block6.value.length || _blockInputPos6 !== _block6.value.length) {\n            return this._blockStartPos(_bi5) + _blockInputPos6;\n          }\n        }\n\n        return 0;\n      }\n\n      if (direction === DIRECTION.RIGHT || direction === DIRECTION.FORCE_RIGHT) {\n        // ->\n        //  any|not-len-aligned and filled\n        //  any|not-len-aligned\n        // <-\n        //  not-0-aligned or start|any\n        var firstInputBlockAlignedIndex;\n        var firstInputBlockAlignedPos;\n\n        for (var _bi6 = searchBlockIndex; _bi6 < this._blocks.length; ++_bi6) {\n          var _block7 = this._blocks[_bi6];\n\n          var _blockInputPos7 = _block7.nearestInputPos(0, DIRECTION.NONE);\n\n          if (_blockInputPos7 !== _block7.value.length) {\n            firstInputBlockAlignedPos = this._blockStartPos(_bi6) + _blockInputPos7;\n            firstInputBlockAlignedIndex = _bi6;\n            break;\n          }\n        }\n\n        if (firstInputBlockAlignedIndex != null && firstInputBlockAlignedPos != null) {\n          for (var _bi7 = firstInputBlockAlignedIndex; _bi7 < this._blocks.length; ++_bi7) {\n            var _block8 = this._blocks[_bi7];\n\n            var _blockInputPos8 = _block8.nearestInputPos(0, DIRECTION.FORCE_RIGHT);\n\n            if (_blockInputPos8 !== _block8.value.length) {\n              return this._blockStartPos(_bi7) + _blockInputPos8;\n            }\n          }\n\n          return direction === DIRECTION.FORCE_RIGHT ? this.value.length : firstInputBlockAlignedPos;\n        }\n\n        for (var _bi8 = Math.min(searchBlockIndex, this._blocks.length - 1); _bi8 >= 0; --_bi8) {\n          var _block9 = this._blocks[_bi8];\n\n          var _blockInputPos9 = _block9.nearestInputPos(_block9.value.length, DIRECTION.LEFT);\n\n          if (_blockInputPos9 !== 0) {\n            var alignedPos = this._blockStartPos(_bi8) + _blockInputPos9;\n\n            if (alignedPos >= cursorPos) return alignedPos;\n            break;\n          }\n        }\n      }\n\n      return cursorPos;\n    }\n    /** Get block by name */\n\n  }, {\n    key: \"maskedBlock\",\n    value: function maskedBlock(name) {\n      return this.maskedBlocks(name)[0];\n    }\n    /** Get all blocks by name */\n\n  }, {\n    key: \"maskedBlocks\",\n    value: function maskedBlocks(name) {\n      var _this4 = this;\n\n      var indices = this._maskedBlocks[name];\n      if (!indices) return [];\n      return indices.map(function (gi) {\n        return _this4._blocks[gi];\n      });\n    }\n  }, {\n    key: \"state\",\n    get: function get() {\n      return Object.assign({}, _get(_getPrototypeOf(MaskedPattern.prototype), \"state\", this), {\n        _blocks: this._blocks.map(function (b) {\n          return b.state;\n        })\n      });\n    },\n    set: function set(state) {\n      var _blocks = state._blocks,\n          maskedState = _objectWithoutProperties(state, [\"_blocks\"]);\n\n      this._blocks.forEach(function (b, bi) {\n        return b.state = _blocks[bi];\n      });\n\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"state\", maskedState, this, true);\n    }\n  }, {\n    key: \"isComplete\",\n    get: function get() {\n      return this._blocks.every(function (b) {\n        return b.isComplete;\n      });\n    }\n  }, {\n    key: \"unmaskedValue\",\n    get: function get() {\n      return this._blocks.reduce(function (str, b) {\n        return str += b.unmaskedValue;\n      }, '');\n    },\n    set: function set(unmaskedValue) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"unmaskedValue\", unmaskedValue, this, true);\n    }\n    /**\r\n      @override\r\n    */\n\n  }, {\n    key: \"value\",\n    get: function get() {\n      // TODO return _value when not in change?\n      return this._blocks.reduce(function (str, b) {\n        return str += b.value;\n      }, '');\n    },\n    set: function set(value) {\n      _set(_getPrototypeOf(MaskedPattern.prototype), \"value\", value, this, true);\n    }\n  }]);\n\n  return MaskedPattern;\n}(Masked);\nMaskedPattern.DEFAULTS = {\n  lazy: true,\n  placeholderChar: '_'\n};\nMaskedPattern.STOP_CHAR = '`';\nMaskedPattern.ESCAPE_CHAR = '\\\\';\nMaskedPattern.InputDefinition = PatternInputDefinition;\nMaskedPattern.FixedDefinition = PatternFixedDefinition;\n\nfunction isInput(block) {\n  if (!block) return false;\n  var value = block.value;\n  return !value || block.nearestInputPos(0, DIRECTION.NONE) !== value.length;\n}\n\nIMask.MaskedPattern = MaskedPattern;\n\nexport default MaskedPattern;\n"]},"metadata":{},"sourceType":"module"}